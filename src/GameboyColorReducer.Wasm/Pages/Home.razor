@page "/"
@using GameboyColorReducer.Core
@using GameboyColorReducer.Core.Models;
@using GameboyColorReducer.Core.ImageConverters
@inject IJSRuntime JS

<h1>Gameboy Color Reducer</h1>
<p>Drag and drop your Gameboy Color image to reduce the number of colours to the original Gameboy Color palette.</p>

<div class="container">
    <div id="original-image-container">
        <h2>Original Image</h2>
        <label for="file-input" class="drop-area" @ref="dropAreaElem">
            <span id="drop-text">Drag your Gameboy Color image here</span>
            <img class="preview-container" @ref="previewImageElem" />
        </label>
        <InputFile id="file-input" @ref="inputFile" OnChange="Process" accept=".png" style="display: none;" />
        <div id="error-container" class="error-container" style="@(string.IsNullOrEmpty(errorMessage) ? "display: none;" : "display: block;")">
            @errorMessage
        </div>
    </div>
    <div id="output-container">
        <div class="reducer-container">
            <h2>Tile Reducer</h2>
            <div class="image-wrapper">
                <img class="preview-container" id="tileReduced" @ref="tileReducedElem" />
                <button class="download-button" onclick="downloadImage('tileReduced', 'tile')" style="display: none;">Download</button>
            </div>
        </div>
        <div class="reducer-container">
            <h2>Art Reducer</h2>
            <div class="image-wrapper">
                <img class="preview-container" id="artReduced" @ref="artReducedElem" />
                <button class="download-button" onclick="downloadImage('artReduced', 'art')" style="display: none;">Download</button>
            </div>
        </div>
    </div>
    <div style="text-align: left;">
        <h2>How does this work?</h2>
        <p>
            <ul>
                <li>Your image is processed in-browser by two different algorithms to quantize/reduce the colours.</li>
                <li>The <strong>Tile Reducer</strong> algorithm quantizes the colours per 8x8 tile and is best suited for tilesets.</li>
                <li>The <strong>Art Reducer</strong> algorithm quantizes the colours to the original Gameboy Color palette and is best suited for art or cutscene stills.</li>
            </ul>
        </p>
        <p>Read more about it on <a href="https://github.com/nikouu/GameboyColorReducer" target="_blank">GitHub</a>.</p>
    </div>
</div>

<script>
    window.initializeDropArea = (dropArea, fileInput) => {
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        dropArea.addEventListener('dragover', preventDefaults);
        dropArea.addEventListener('dragenter', preventDefaults);
        dropArea.addEventListener('dragleave', preventDefaults);

        dropArea.addEventListener('drop', handleDrop);

        function handleDrop(e) {
            preventDefaults(e);
            const dt = e.dataTransfer;
            const files = dt.files;
            fileInput.files = files;
            fileInput.dispatchEvent(new Event('change'));
        }

        dropArea.addEventListener('dragover', () => {
            dropArea.classList.add('drag-over');
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('drag-over');
        });

        window.setupPreviewImage = (inputElem, imgElem) => {
            const dropText = document.getElementById('drop-text');
            dropText.style.display = 'none';

            window.setImageSrc(inputElem, imgElem);
        }

        window.setImageSrc = (imgElem, src) => {
            imgElem.src = src;
            showDownloadButton(imgElem);
        };

        window.showDownloadButton = (imgElem) => {
            const button = imgElem.nextElementSibling;
            if (button && button.classList.contains('download-button')) {
                button.style.display = 'block';
            }
        }

        window.hideDownloadButtons = () => {
            const buttons = document.querySelectorAll('.download-button');
            buttons.forEach(button => {
                button.style.display = 'none';
            });
        };

        window.downloadImage = (elemRef, suffix) => {
            const imgElem = document.getElementById(elemRef);
            const fileInput = document.getElementById('file-input');
            if (imgElem && fileInput && fileInput.files.length > 0) {
                const originalFilename = fileInput.files[0].name;
                const dotIndex = originalFilename.lastIndexOf('.');
                const filename = dotIndex !== -1
                    ? `${originalFilename.substring(0, dotIndex)}-${suffix}${originalFilename.substring(dotIndex)}`
                    : `${originalFilename}-${suffix}`;

                const link = document.createElement('a');
                link.href = imgElem.src;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }
</script>

@code {
    private InputFile? inputFile;
    private ElementReference previewImageElem;
    private ElementReference dropAreaElem;
    private ElementReference tileReducedElem;
    private ElementReference artReducedElem;
    private ImageSharpImageConverter imageSharpImageConverter;
    private ColourReducer colourReducer;
    private string errorMessage = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        imageSharpImageConverter = new ImageSharpImageConverter();
        colourReducer = new ColourReducer();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("initializeDropArea", dropAreaElem, inputFile!.Element);
        }
    }

    private async Task Process(InputFileChangeEventArgs e)
    {
        try
        {
            errorMessage = string.Empty;
            var file = e.File;
            var buffer = new byte[file.Size];
            await file.OpenReadStream(maxAllowedSize: 1024000).ReadAsync(buffer);

            await JS.InvokeVoidAsync("setupPreviewImage", previewImageElem, GetDataUrl(buffer));

            var image = await Task.Run(() => imageSharpImageConverter.ToWorkingImage(buffer));

            var tileReducedTask = Task.Run(() =>
            {
                var tileImage = imageSharpImageConverter.ToWorkingImage(buffer);
                colourReducer.QuantizePerTile(tileImage);
                var tileReduced = imageSharpImageConverter.ToByteArray(tileImage);
                return tileReduced;
            });

            var artReducedTask = Task.Run(() =>
            {
                var artImage = imageSharpImageConverter.ToWorkingImage(buffer);
                colourReducer.QuantizeToGameBoyPalette(artImage);
                var artReduced = imageSharpImageConverter.ToByteArray(artImage);
                return artReduced;
            });

            await Task.WhenAll(tileReducedTask, artReducedTask);

            var tileReduced = await tileReducedTask;
            var artReduced = await artReducedTask;

            await InvokeAsync(() => JS.InvokeVoidAsync("setImageSrc", tileReducedElem, GetDataUrl(tileReduced)));
            await InvokeAsync(() => JS.InvokeVoidAsync("setImageSrc", artReducedElem, GetDataUrl(artReduced)));
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
            await ClearPreviewContainers();
            await HideDownloadButtons();
            await InvokeAsync(StateHasChanged);
            Console.WriteLine(ex);
        }
    }

    private string GetDataUrl(byte[] buffer)
    {
        var base64String = Convert.ToBase64String(buffer);
        var imageDataUrl = $"data:image/png;base64,{base64String}";
        return imageDataUrl;
    }

    private async Task ClearPreviewContainers()
    {
        await JS.InvokeVoidAsync("setImageSrc", tileReducedElem, "");
        await JS.InvokeVoidAsync("setImageSrc", artReducedElem, "");
    }

    private async Task HideDownloadButtons()
    {
        await JS.InvokeVoidAsync("hideDownloadButtons");
    }
}
