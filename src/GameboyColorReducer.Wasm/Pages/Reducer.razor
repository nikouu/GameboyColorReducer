@page "/reducer"
@using GameboyColorReducer.Core
@using GameboyColorReducer.Core.Models;
@using GameboyColorReducer.Core.ImageConverters
@using BlazorWorker.BackgroundServiceFactory
@using BlazorWorker.Core
@inject IWorkerFactory workerFactory
@inject IJSRuntime JS

<h1>Gameboy Color Reducer</h1>

<div class="container text-center">
    <div class="row">
        <div class="col">
            <h2>Original Image</h2>
            <label for="file-input" class="drop-area" @ref="dropAreaElem">
                <span id="drop-text">Drag your Gameboy Color image here</span>
                <img class="preview-container" @ref="previewImageElem" />
            </label>
            <InputFile id="file-input" @ref="inputFile" OnChange="Process" style="display: none;" />
        </div>
    </div>
    <div class="row">
        <div class="col">
            <h2>Tile Reducer</h2>
            <img class="preview-container" @ref="tileReducedElem" />
        </div>
        <div class="col">
            <h2>Art Reducer</h2>
            <img class="preview-container" @ref="artReducedElem" />
        </div>
    </div>
</div>

<script>
    window.initializeDropArea = (dropArea, fileInput) => {
        // Utility function to prevent default browser behavior
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Preventing default browser behavior when dragging a file over the container
        dropArea.addEventListener('dragover', preventDefaults);
        dropArea.addEventListener('dragenter', preventDefaults);
        dropArea.addEventListener('dragleave', preventDefaults);

        // Handling dropping files into the area
        dropArea.addEventListener('drop', handleDrop);

        function handleDrop(e) {
            preventDefaults(e);
            const dt = e.dataTransfer;
            const files = dt.files;
            fileInput.files = files;
            fileInput.dispatchEvent(new Event('change'));
        }

        dropArea.addEventListener('dragover', () => {
            dropArea.classList.add('drag-over');
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('drag-over');
        });

        window.setupPreviewImage = (inputElem, imgElem) => {
            const dropText = document.getElementById('drop-text');
            dropText.style.display = 'none';

            window.setImageSrc(inputElem, imgElem);
        }

        window.setImageSrc = (imgElem, src) => {
            imgElem.src = src;
        };

        window.previewImage = (inputElem, imgElem) => {
            const dropText = document.getElementById('drop-text');
            dropText.style.display = 'none';

            const url = URL.createObjectURL(inputElem.files[0]);
            imgElem.addEventListener('load', () => URL.revokeObjectURL(url), { once: true });
            imgElem.src = url;
        }
    }
</script>

@code {
    private InputFile? inputFile;
    private ElementReference previewImageElem;
    private ElementReference dropAreaElem;
    private ElementReference tileReducedElem;
    private ElementReference artReducedElem;
    private ImageSharpImageConverter imageSharpImageConverter;
    private ColourReducer colourReducer;

    protected override async Task OnInitializedAsync()
    {
        imageSharpImageConverter = new ImageSharpImageConverter();
        colourReducer = new ColourReducer();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("initializeDropArea", dropAreaElem, inputFile!.Element);
        }
    }

    private async Task Process(InputFileChangeEventArgs e)
    {
        var file = e.File;
        var buffer = new byte[file.Size];
        await file.OpenReadStream().ReadAsync(buffer);

        await JS.InvokeVoidAsync("setupPreviewImage", previewImageElem, GetDataUrl(buffer));
        //await JS.InvokeVoidAsync("previewImage", inputFile!.Element, previewImageElem);

        // var image = await Task.Run(() => imageSharpImageConverter.ToWorkingImage(buffer));

        // var tileReducedTask = Task.Run(() =>
        // {
        //     var tileImage = imageSharpImageConverter.ToWorkingImage(buffer); // Create a separate instance for tile reduction
        //     colourReducer.QuantizePerTile(tileImage);
        //     var tileReduced = imageSharpImageConverter.ToByteArray(tileImage);
        //     return tileReduced;
        // });

        // var artReducedTask = Task.Run(() =>
        // {
        //     var artImage = imageSharpImageConverter.ToWorkingImage(buffer); // Create a separate instance for art reduction
        //     colourReducer.QuantizeToGameBoyPalette(artImage);
        //     var artReduced = imageSharpImageConverter.ToByteArray(artImage);
        //     return artReduced;
        // });

        // await Task.WhenAll(tileReducedTask, artReducedTask);

        // // already completed
        // var tileReduced = await tileReducedTask;
        // var artReduced = await artReducedTask;

        // await InvokeAsync(() => JS.InvokeVoidAsync("setImageSrc", tileReducedElem, GetDataUrl(tileReduced)));
        // await InvokeAsync(() => JS.InvokeVoidAsync("setImageSrc", artReducedElem, GetDataUrl(artReduced)));

        var worker = await workerFactory.CreateAsync();
        var converterService = await worker.CreateBackgroundServiceAsync<ImageSharpImageConverter>();
        var reducerService = await worker.CreateBackgroundServiceAsync<ColourReducer>();

        //var image2 = await converterService.RunAsync(x => x.ToWorkingImage(buffer));

        var image2 = await Task.Run(() => imageSharpImageConverter.ToWorkingImage(buffer));

        await reducerService.RunAsync(x => x.QuantizePerTile(image2));
        var tileReduced2 = await converterService.RunAsync(x => x.ToByteArray(image2));

        await reducerService.RunAsync(x => x.QuantizeToGameBoyPalette(image2));
        var artReduced2 = await converterService.RunAsync(x => x.ToByteArray(image2));

        await InvokeAsync(() => JS.InvokeVoidAsync("setImageSrc", tileReducedElem, GetDataUrl(tileReduced2)));
        await InvokeAsync(() => JS.InvokeVoidAsync("setImageSrc", artReducedElem, GetDataUrl(artReduced2)));        
    }

    private string GetDataUrl(byte[] buffer)
    {
        var base64String = Convert.ToBase64String(buffer);
        var imageDataUrl = $"data:image/png;base64,{base64String}";
        return imageDataUrl;
    }
}
